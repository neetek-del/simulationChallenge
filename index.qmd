---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

```{python}
#| echo: false
import numpy as np
import matplotlib.pyplot as plt


PALETTE = {
"accent": "#0E76A8", # deep ocean blue
"accent2": "#2AB7CA", # teal
"soft": "#9BD1E5", # soft sky
"highlight": "#044E54",# dark teal
"neutral": "#F6FDFF" # off-white
}

plt.rcParams.update({
"figure.facecolor": "white",
"axes.facecolor": "white",
"axes.edgecolor": "#333333",
"axes.labelsize": 12,
"axes.titlesize": 14,
"xtick.labelsize": 10,
"ytick.labelsize": 10,
"legend.fontsize": 10,
"font.family": "DejaVu Sans"
})

RNG = np.random.default_rng(2025) # reproducible RNG
```


### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

Explanation:

After flipping the coin once, the expected value of the account balance comes out to about $31,500 starting from $30,000.
Thatâ€™s roughly a 5% gain, which sounds pretty good at first.

Basically, if I played this game one time, I would expect to end up with more money on average â€” like a small profit.

So yes, by the numbers it looks like a good deal.

But honestly, that is just the average outcome. In real life, with a 50% gain or a 40% loss each flip, things can go bad real fast for a single player â€” so itâ€™s not as safe as it looks.

Visualization:

Colored Lines â€“ Individual Player Paths
The colored lines illustrate the simulated paths taken by five different players as they move through ten rounds of coin flips. Everyone begins at the same starting point of $30,000, but from there their paths diverge based on random wins and losses. These lines highlight the natural volatility of the game: some players hit lucky streaks and their balances rise sharply, while others encounter downturns and see their balances fall.

Black Line â€“ Expected Value Trend
The solid black line represents the expected value, or the theoretical average outcome if the game were repeated an extremely large number of times. In this simulation, the expected value shows a steady upward trend, indicating that the game provides a small long-term advantage to the player (about a 5% average gain per flip).

X-Axis â€“ Number of Flips
The horizontal axis tracks the progression through the game, starting at 0 flips and ending at 10 flips. It helps the viewer see how each player's balance changes over time.

Y-Axis â€“ Account Balance ($)
The vertical axis displays the playersâ€™ account balances in dollars. This scale makes it easy to compare how high or low each playerâ€™s balance goes as the simulation unfolds.

In summary - This visualization compares five simulated player outcomes with the theoretical expected value of a coin-flip game. While all players start with the same balance, their colored paths quickly diverge, showing how randomness creates big swingsâ€”some rising sharply with lucky streaks, others falling due to losses. The black line provides a steady benchmark, representing the average result weâ€™d expect over many repetitions of the game. Together, the chart highlights both the volatility of individual experiences and the long-term upward trend implied by the gameâ€™s positive expected value.


```{python}
#| label: q1-expected-value-py
#| echo: true

# TODO: Compute EV after one flip in Python
# - Show calculation and brief explanation

import matplotlib.pyplot as plt
import numpy as np

# Initial buy-in
W0 = 30000.0  # Use float for consistency

# Expected value after one flip
EV_after_1 = 0.5 * (1.5 * W0) + 0.5 * (0.6 * W0)
gain_pct = (EV_after_1 - W0) / W0 * 100

print(f"EV after 1 flip = ${EV_after_1:,.2f}  ({gain_pct:.2f}%)")
print(f"Expected value after one flip is {EV_after_1:.2f}, "
      f"which is a gain of {gain_pct:.2f}% of your buy-in.")

# Optional: visualize expected value over multiple flips
import numpy as np
import matplotlib.pyplot as plt

# Initial buy-in
W0 = 30000.0
num_flips = 10
num_simulations = 5  # Number of simulated players

# Simulate coin flips (this block is a duplicate of the later visualization and can be removed or kept for a simpler run)
simulations = np.zeros((num_simulations, num_flips + 1))
simulations[:, 0] = W0

for i in range(num_simulations):
    for j in range(1, num_flips + 1):
        if np.random.rand() < 0.5:  # Win
            simulations[i, j] = simulations[i, j-1] * 1.5
        else:  # Loss
            simulations[i, j] = simulations[i, j-1] * 0.6

# Show EV growth over a few flips (theoretically multiplies by 1.05 each flip)

num_flips = 10
EVs = [W0 * (1.05 ** t) for t in range(num_flips + 1)]

# Plot example simulation paths (5 random players) vs EV

np.random.seed(2025) # Seed for reproducibility
n_paths = 5
paths = np.zeros((n_paths, num_flips + 1))
paths[:, 0] = W0

for i in range(n_paths):
    for t in range(1, num_flips + 1): # Added correct indentation
        win = np.random.rand() < 0.5 # Replaced undefined 'RNG.random()' with 'np.random.rand()'
        paths[i, t] = paths[i, t-1] * (1.5 if win else 0.6)

# Define a simple color palette if PALETTE is not defined elsewhere
try:
    PALETTE
except NameError:
    PALETTE = {"highlight": "orangered"}

plt.figure(figsize=(10,4.5))
for i in range(n_paths):
    plt.plot(range(num_flips+1), paths[i], marker='o', alpha=0.8, label=f'Player {i+1}', linewidth=1.8)
plt.plot(range(num_flips+1), EVs, marker='s', color=PALETTE["highlight"], linewidth=3, label='Expected Value (1.05^t)')

plt.title("Five Example Paths vs Theoretical Expected Value")
plt.xlabel("Number of Flips")
plt.ylabel("Account Balance ($)")
plt.grid(alpha=0.25, linestyle='--')
plt.legend(loc='upper left')
plt.tight_layout()
plt.show()



```

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

Explanation:

At the beginning, the balance jumps up a few times, even reaching over $60,000, but the growth doesnâ€™t last long.
After several unlucky flips, the value drops sharply and keeps falling until it almost hits zero.

This pattern shows how unpredictable and risky the game is. Even though the balance had strong gains early on, a few losses in a row wiped out most of the wealth. Over time, the compounding losses dominate, leaving very little money left by the end.

Overall, the outcome looks unstable and risky â€” it shows that while short-term wins are possible, the long-term result is usually disappointing.

```{python}
#| label: q2-single-sim-py
#| fig-cap: "Single 40-year simulation path (Ocean Blue palette)"
#| echo: true

import numpy as np
import matplotlib.pyplot as plt

# --- Settings ---
W0 = 30000.0            # Starting balance
N = 40                  # Number of flips (years)
np.random.seed(2025)    # Reproducibility

# Color palette
PALETTE = {
    "path": "steelblue",
    "initial": "darkred",
    "highlight": "orangered",
    "box": "bisque"
}

# --- Single simulation path ---
W = [W0]
for _ in range(N):
    win = np.random.rand() < 0.5
    W.append(W[-1] * (1.5 if win else 0.6))

# --- Plot ---
plt.figure(figsize=(10, 4.2))
plt.plot(range(N+1), W, marker='o', linewidth=2,
         label='Single Simulation Path', color=PALETTE["path"])

plt.axhline(W0, color=PALETTE["initial"], linestyle='--', linewidth=2,
            label="Initial $30k")

plt.title("Single Simulation Path of Account Balance (40 Years)")
plt.xlabel("Year")
plt.ylabel("Balance ($)")
plt.grid(alpha=0.25)
plt.legend()

# Annotation for final value
plt.annotate(
    f"Final: ${W[-1]:,.0f}",
    xy=(N, W[-1]),
    xytext=(N - 6, max(W) * 0.7),
    arrowprops=dict(arrowstyle="->", color=PALETTE["highlight"]),
    bbox=dict(boxstyle="round,pad=0.3", fc=PALETTE["box"])
)

plt.tight_layout()
plt.show()

# --- Print summary ---
print(f"Starting balance: ${W0:,.2f}")


```

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

Explanation:

After running 100 simulations of this investment game over 40 years, the distribution of final account balances is very uneven. Most of the time, the final wealth ends up much lower than the initial $30,000 investment. This shows that in the majority of cases, the investment loses significant value.

However, there are a few rare simulations where the final wealth grows extremely large, reaching into the millions. These few big wins pull the average final wealth upward, but they are exceptions rather than the rule.

The probability of ending with more than $30,000â€”the amount initially investedâ€”is quite low. This means that most players would not be happy with the outcome, as their investment decreases over time in most cases.

In summary, while the game offers a small chance for very high returns, the majority of outcomes are losses, making it a risky investment.


```{python}
plt.figure(figsize=(14, 6))

# Use log scale for x-axis
bins = np.logspace(np.log10(finals.min()), np.log10(finals.max()), 22)

counts, bins, patches = plt.hist(
    finals,
    bins=bins,
    edgecolor='black',
    linewidth=1.2
)

for patch, left_edge in zip(patches, bins[:-1]):
    if left_edge < W0:
        patch.set_facecolor("#ff6b6b")   # light red
    else:
        patch.set_facecolor("#4db6ac")   # teal/green

plt.axvline(W0, color="#d32f2f", linestyle="--", linewidth=3, label="Initial $30k")
plt.axvline(mean_final, color="#2e7d32", linestyle="-", linewidth=3, label="Mean")
plt.axvline(median_final, color="#1565c0", linestyle=":", linewidth=3, label="Median")

plt.xscale("log")  # important for clarity
plt.title("Distribution of Final Balances Across 100 Simulations", fontsize=16)
plt.xlabel("Final Account Balance ($)", fontsize=13)
plt.ylabel("Count", fontsize=13)
plt.grid(axis='y', alpha=0.35, linestyle='--')
plt.legend(fontsize=12)
plt.tight_layout()
plt.show()



```


### 4) Probability Balance > $30,000 at Age 75 (Original Game)
```{python}
## The code below simulates two investment strategies and plots a comparison histogram.

import numpy as np
import matplotlib.pyplot as plt

# A color palette that defines all the keys used in the plotting code.
PALETTE = {
    "soft": "lightgrey",
    "accent2": "steelblue"
}

# Assume W0 and other variables are defined in previous cells
# W0 = 30000.0
# prob_above_30k_large = 0.2142

# Corrected code snippet
vals = [1 - prob_above_30k_large, prob_above_30k_large]
labels = ['â‰¤ $30k', '> $30k']
colors = [PALETTE["soft"], PALETTE["accent2"]]
bars = plt.bar(labels, vals, color=colors, edgecolor='black')
plt.ylim(0, 1)

# Add title, labels, and show plot
plt.title("Probability of Final Wealth Outcome")
plt.ylabel("Probability")
plt.tight_layout()
plt.show()



```



### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

Explanation:

This chart shows the results of a modified investment strategy where only a portion of the total balance (25%) is risked each round. The explanation highlights the key differences of this strategy compared to a full-bet approach:

Risk Reduction: The ups and downs of the investment are much milder and more stable. The chances of a player losing all their money are significantly reduced.
Wealth Distribution: Most of the final balances, as shown by the taller bars, are clustered between $20,000 and $100,000.
Lower Upside Potential: While the strategy is safer, it also makes it less likely to achieve extremely large gains. As seen by the few, small bars on the far right, very high final wealth amounts are rare.
Summary: The modified strategy offers a much smoother, less risky investment path, but it comes with a trade-off of having a lower potential for huge profits.


```{python}
# The code below simulates two investment strategies and plots a comparison histogram.
# It addresses the IndentationError and the KeyError.

import numpy as np
import matplotlib.pyplot as plt

# A color palette that defines all the keys used in the plotting code.
PALETTE = {
    "accent": "lightcoral",
    "accent2": "steelblue",
    "highlight": "goldenrod"
}

# Initial buy-in and number of years for the simulation
W0 = 30000.0
N = 40

np.random.seed(2025)

def simulate_full_bet(sims=1000, N=40, W0=30000):
    """Simulates the full bet strategy and returns final balances."""
    res = []
    for s in range(sims):
        Wt = W0
        for t in range(N):
            if np.random.rand() < 0.5:
                Wt *= 1.5
            else:
                Wt *= 0.6
        res.append(Wt)
    return np.array(res)

def simulate_fractional_bet(f=0.25, sims=1000, N=40, W0=30000):
    """Simulates the fractional bet strategy and returns final balances."""
    res = []
    for s in range(sims):
        Wt = W0
        for t in range(N):
            r = 0.5 if np.random.rand() < 0.5 else -0.4
            Wt *= (1 + f * r)
        res.append(Wt)
    return np.array(res)

sims = 2000
orig_res = simulate_full_bet(sims=sims, N=N, W0=W0)
mod_res = simulate_fractional_bet(f=0.25, sims=sims, N=N, W0=W0)

# Summaries
orig_mean, orig_median, orig_p = orig_res.mean(), np.median(orig_res), np.mean(orig_res > W0)
mod_mean, mod_median, mod_p = mod_res.mean(), np.median(mod_res), np.mean(mod_res > W0)

print("Original (full bet): mean={:.2f}, median={:.2f}, P(>30k)={:.3f}".format(orig_mean, orig_median, orig_p))
print("Modified (25% bet): mean={:.2f}, median={:.2f}, P(>30k)={:.3f}".format(mod_mean, mod_median, mod_p))

# Visual comparison histograms (overlayed)

plt.figure(figsize=(10,4.5))
bins = np.linspace(0, np.percentile(np.concatenate([orig_res, mod_res]), 99.5), 60)
plt.hist(orig_res, bins=bins, alpha=0.55, label='Original (full bet)', edgecolor='black', color=PALETTE["accent"])
plt.hist(mod_res, bins=bins, alpha=0.65, label='Modified (25% bet)', edgecolor='black', color=PALETTE["accent2"])
plt.axvline(W0, color=PALETTE["highlight"], linestyle='--', linewidth=2, label=f"Initial ${W0:,.0f}")
plt.title("Final Balance: Full Bet vs 25% Bet (2000 sims each)")
plt.xlabel("Final Balance ($) -- clipped to 99.5 percentile for visibility")
plt.ylabel("Frequency")
plt.legend()
plt.grid(alpha=0.18)
plt.tight_layout()
plt.show()





```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?

Explanation:

The modified strategy shown in the chart, which involves betting only 25% of the total balance per round, is a practical application of a Kelly-like approach. In this context, it appears to be a more conservative strategy than betting the full amount. By risking only a small portion of the capital each time, the strategy aims to:

Minimize the risk of ruin (losing all capital).
Avoid the wild swings in fortune that come with high-stakes betting.
Achieve more stable, albeit slower, long-term growth.
The Kelly Criterion would likely recommend a specific fraction to bet that is less than the full amount, which is consistent with the modified strategy's use of a 25% bet. This approach explains why the final wealth values in the histogram are more clustered and stable, rather than scattered or extreme.


```{python}
#| label: q6-kelly-py
#| echo: true

import numpy as np
import matplotlib.pyplot as plt

# Define a color palette if it's not defined elsewhere
try:
    PALETTE
except NameError:
    PALETTE = {
        "accent": "darkcyan",
        "highlight": "crimson",
        "accent2": "goldenrod"
    }

# outcomes and probabilities: r_win = +0.5 with p=0.5, r_loss = -0.4 with q=0.5
p = 0.5
r_win = 0.5
r_loss = -0.4

def expected_log_growth(f, p=0.5, r_win=0.5, r_loss=-0.4):
    """
    Calculates the expected log growth for a given bet fraction 'f'.
    Handles both scalar (single float) and vectorized (NumPy array) inputs.
    """
    # Check if the input is a single float or a NumPy array
    is_scalar = not isinstance(f, np.ndarray)
    
    # If a scalar, wrap it in an array to use vectorized logic
    f_input = np.array([f]) if is_scalar else f
    
    # Check for invalid inputs that would lead to a non-positive log argument
    invalid_f = (1 + f_input * r_loss <= 0) | (1 + f_input * r_win <= 0)
    
    # Initialize an array for the results and set invalid entries to -np.inf
    val = np.zeros_like(f_input, dtype=float)
    val[invalid_f] = -np.inf
    
    # Compute the value for valid inputs
    valid_f = ~invalid_f
    val[valid_f] = p * np.log(1 + f_input[valid_f] * r_win) + (1 - p) * np.log(1 + f_input[valid_f] * r_loss)
    
    # If the original input was a scalar, return a scalar
    return val[0] if is_scalar else val

# grid search for f in [0,1]
fs = np.linspace(0.0, 1.0, 10001)

# Use the vectorized approach on the array `fs`
vals = expected_log_growth(fs)

# Find the f that maximizes the expected log growth
f_star = fs[np.nanargmax(vals)]
print(f"Numerical Kelly-optimal fraction (f*): {f_star:.4f}")

# Evaluate expected log growth at 0.25 (your modified strategy)
# The function now handles this single float input correctly.
val_25 = expected_log_growth(0.25)
val_star = expected_log_growth(f_star)
print(f"E[log growth] at f=0.25: {val_25:.6f}")
print(f"E[log growth] at f*={f_star:.4f}: {val_star:.6f}")

# Plot E[log] vs f
plt.figure(figsize=(8,3.6))
plt.plot(fs, vals, color=PALETTE["accent"], linewidth=2)
plt.axvline(f_star, color=PALETTE["highlight"], linestyle='--', label=f'f* = {f_star:.3f}')
plt.axvline(0.25, color=PALETTE["accent2"], linestyle=':', label='f = 0.25')
plt.title("Expected Log-Growth vs Bet Fraction (Kelly objective)")
plt.xlabel("Bet fraction f")
plt.ylabel("E[log(1 + f r)]")
plt.legend()
plt.grid(alpha=0.2)
plt.tight_layout()
plt.show()
```

## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

